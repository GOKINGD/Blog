---
title: 深入理解cpp-拷贝和移动
date: 2024-07-14 16:10:08
tags: [C++]
categories: C++
---

# 摘要
本文将详细介绍C++中的拷贝构造函数、移动构造函数、拷贝赋值函数和移动赋值函数。

# 前言
其实，简单的理解，构造函数就是通过这个函数构造一个类的实例对象，即提供参数进行直接初始化。而拷贝构造函数是通过拷贝的方式，提供一个存在的对象拷贝一份进行拷贝初始化。而移动构造函数是利用移动构造函数来获取另一个对象的所有权，而不进行拷贝进行移动初始化。

# explicit
首先先来了解explicit关键字。
explicit翻译过来就是显示的。explicit用于修饰构造函数，表明构造函数只能用于显式构造，而不能用于隐式转换。
例如下面的例子：
```c++
class A{
public:
    A(int a){

    }
};

A a = new A(1); //显式定义
A a(1);
A a{1}; //c++11的列表初始化
A a = 1; //隐式转换
```
而如果类A的构造函数加了explicit，则不能使用隐式转换:
```c++
class A{
public:
    explicit A(int a){

    }
};

A a = 1; //隐式转换 非法！
A a = {1}; //非法
```

特别的，对于**单参数**的构造函数，最好是声明为explicit，减少隐式转换。

# 拷贝
## 拷贝构造函数
直接看例子：
```c++
class sta{
public:
    sta(); //构造函数
    sta(const sta&); //拷贝构造函数
private:
    int a;
    std::string b;
};

sta::sta(const sta &st){
    a = st.a;
    b = st.b;
}
```
通常来说，拷贝构造函数的第一个参数必须是**引用类型**。倘若不是引用类型，则在调用拷贝构造函数之前，就需要先在传参的过程中，执行拷贝的操作。这个时候又需要拷贝构造函数了，因为你没有定义如何拷贝一个对象的操作。这个时候就造成了死循环。
换句话说，拷贝构造函数定义了类对象间如何进行拷贝，所以需要用引用完成拷贝的详细过程。

同时，拷贝构造函数通常都是const类型的，这是因为一般不会修改拷贝的对象。

同时，拷贝构造函数几乎都会被隐式使用，所以不应该设置为explicit类型，例如：
```c++
std::string str = "123456"; //拷贝初始化
std::string str2 = string(100,'9'); //拷贝初始化
```
## 拷贝赋值运算符
通过拷贝赋值运算符，即对赋值运算符进行重载，可以实现对类进行赋值。
例如：
```c++
class A{
public:
    A& operator=(const A&);
};
A a,aa;
a = aa; //赋值运算
```

**需要使用拷贝构造函数的类型，也必然需要一个拷贝赋值运算符**
## 内联函数inline
内敛函数的目的是为了提高函数的执行效率。内联函数会在函数调用点展开函数，而不是压栈进行调用，提高性能。
这是一个编译器关键字，编译器可能还会根据函数的大小和其他因素来决定是否将函数内联。

## default和delete
首先，如果没有定义拷贝构造函数和拷贝赋值运算符，编译器会生成默认的拷贝构造函数和拷贝赋值运算符，也叫做**合成拷贝构造函数**和**合成拷贝赋值运算符**。

而通过default关键字，可以用来显示地让编译器直接生成**合成拷贝构造函数**和**合成拷贝赋值运算符**，例如：
```c++
class sta{
public:
    sta() = default;
    sta(const sta&) = default;
    sta& operator=(const sta&) = default;
    ~sta() = default;
};

```
在类内直接定义default的成员函数是inline函数，而如果不想定义为inline函数，则可以在类外定义default，例如：
```c++
class sta{
public:
    sta& operator=(const sta&);
};

sta& operator=(const sta&) = default;

```

而通过delete关键字，可以阻止类进行拷贝和赋值。例如：
```c++
class sta{
    sta() = default;
    sta(const sta&) = delete; //阻止拷贝
    sta &operator=(const sta&) = delete; //阻止赋值
}

```

**当类中的一些成员无法被默认构造、拷贝或者无法被析构的时候，那么对应的成员函数将被定义为删除的**

# 移动
## 左值和右值
最简单的理解就是，表达式左边的值就是左值，表达式右边的值是右值。
本质上，左值是持久的，而右值是短暂的，将要被销毁的。
通常，引用一般值得是左值引用，同样，右值也有引用，右值引用就是右值的别名，例如：
```c++
int i = 1;  //i是左值
int &j = i; //j是左值引用
int &&rr = i*2; //rr是右值

int &r1 = i * 2; //非法的，左值不能绑定右值
const int &r2 = i*2; //正确的，const引用可以绑定右值
```
## std::move
std::move的作用就是将一个左值转换为一个右值。
例如：
```c++
int r = 1;
int &&rr = std::move(r);
```

左值和右值以及move的提出，就是为了移动语义。
正常来说，左值赋值给左值会发生拷贝，移后源对象仍然存在。但是当我们使用move使得一个左值转成了一个右值，那么赋值过程中就不存在拷贝了，而是获得其所有权。
## 移动构造函数
移动构造函数类似于拷贝构造函数，第一个参数必须是该类型的一个引用，并且是一个右值引用。并且任何额外的参数都必须有默认实参。
例如：
```c++
class sta{
    sta(sta &&st) noexcept {
        a = st.a;
        b = st.b;
        st.a = st.b = nullptr;
    }
};
```
移动构造函数不会分配任何新的内存，只是获得st的所有权，获得所有权后，就需要把其中的指针设置为nullptr，在移动后，原来的对象就会被销毁，而我们的新的对象就获得了原来的对象。

注意到，移动构造函数被声明为noexcept了。我们必须在类的声明和定义中，都同时指定noexcept

## 移动赋值函数