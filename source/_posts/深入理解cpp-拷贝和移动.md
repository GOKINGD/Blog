---
title: 深入理解cpp-拷贝和移动
date: 2024-07-14 16:10:08
tags: [C++]
categories: C++
---

# 摘要
本文将详细介绍C++中的拷贝构造函数、移动构造函数、拷贝赋值函数和移动赋值函数。

# 前言
其实，简单的理解，构造函数就是通过这个函数构造一个类的实例对象，即提供参数进行直接初始化。而拷贝构造函数是通过拷贝的方式，提供一个存在的对象拷贝一份进行拷贝初始化。而移动构造函数是利用移动构造函数来获取另一个对象的所有权，而不进行拷贝进行移动初始化。

# explicit
首先先来了解explicit关键字。
explicit翻译过来就是显示的。explicit用于修饰构造函数，表明构造函数只能用于显式构造，而不能用于隐式转换。
例如下面的例子：
```c++
class A{
public:
    A(int a){

    }
};

A a = new A(1); //显式定义
A a(1);
A a{1}; //c++11的列表初始化
A a = 1; //隐式转换
```
而如果类A的构造函数加了explicit，则不能使用隐式转换:
```c++
class A{
public:
    explicit A(int a){

    }
};

A a = 1; //隐式转换 非法！
A a = {1}; //非法
```

特别的，对于**单参数**的构造函数，最好是声明为explicit，减少隐式转换。

# 拷贝
## 拷贝构造函数
直接看例子：
```c++
class sta{
public:
    sta(); //构造函数
    sta(const sta&); //拷贝构造函数
private:
    int a;
    std::string b;
};

sta::sta(const sta &st){
    a = st.a;
    b = st.b;
}
```
通常来说，拷贝构造函数的第一个参数必须是**引用类型**。倘若不是引用类型，则在调用拷贝构造函数之前，就需要先在传参的过程中，执行拷贝的操作。这个时候又需要拷贝构造函数了，因为你没有定义如何拷贝一个对象的操作。这个时候就造成了死循环。
换句话说，拷贝构造函数定义了类对象间如何进行拷贝，所以需要用引用完成拷贝的详细过程。

同时，拷贝构造函数通常都是const类型的，这是因为一般不会修改拷贝的对象。

同时，拷贝构造函数几乎都会被隐式使用，所以不应该设置为explicit类型，例如：
```c++
std::string str = "123456"; //拷贝初始化
std::string str2 = string(100,'9'); //拷贝初始化
```
## 拷贝赋值运算符
通过拷贝赋值运算符，即对赋值运算符进行重载，可以实现对类进行赋值。
例如：
```c++
class A{
public:
    A& operator=(const A&);
};
A a,aa;
a = aa; //赋值运算
```

**需要使用拷贝构造函数的类型，也必然需要一个拷贝赋值运算符**
## 内联函数inline
内敛函数的目的是为了提高函数的执行效率。内联函数会在函数调用点展开函数，而不是压栈进行调用，提高性能。
这是一个编译器关键字，编译器可能还会根据函数的大小和其他因素来决定是否将函数内联。

## default和delete
首先，如果没有定义拷贝构造函数和拷贝赋值运算符，编译器会生成默认的拷贝构造函数和拷贝赋值运算符，也叫做**合成拷贝构造函数**和**合成拷贝赋值运算符**。

而通过default关键字，可以用来显示地让编译器直接生成**合成拷贝构造函数**和**合成拷贝赋值运算符**，例如：
```c++
class sta{
public:
    sta() = default;
    sta(const sta&) = default;
    sta& operator=(const sta&) = default;
    ~sta() = default;
};

```
在类内直接定义default的成员函数是inline函数，而如果不想定义为inline函数，则可以在类外定义default，例如：
```c++
class sta{
public:
    sta& operator=(const sta&);
};

sta& operator=(const sta&) = default;

```

而通过delete关键字，可以阻止类进行拷贝和赋值。例如：
```c++
class sta{
    sta() = default;
    sta(const sta&) = delete; //阻止拷贝
    sta &operator=(const sta&) = delete; //阻止赋值
}

```

**当类中的一些成员无法被默认构造、拷贝或者无法被析构的时候，那么对应的成员函数将被定义为删除的**

# 移动
## 左值和右值

## std::move


## 移动构造函数


## 移动赋值函数